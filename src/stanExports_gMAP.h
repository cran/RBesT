// Generated by rstantools.  Do not edit by hand.

/*
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace model_gMAP_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 184> locations_array__ =
  {" (found before start of program)",
  " (in 'gMAP', line 126, column 2 to column 32)",
  " (in 'gMAP', line 127, column 2 to column 31)",
  " (in 'gMAP', line 128, column 2 to column 30)",
  " (in 'gMAP', line 131, column 2 to column 18)",
  " (in 'gMAP', line 132, column 2 to column 18)",
  " (in 'gMAP', line 133, column 2 to column 27)",
  " (in 'gMAP', line 194, column 2 to column 18)",
  " (in 'gMAP', line 195, column 2 to column 23)",
  " (in 'gMAP', line 134, column 2 to column 59)",
  " (in 'gMAP', line 139, column 4 to column 61)",
  " (in 'gMAP', line 137, column 4 to column 28)",
  " (in 'gMAP', line 136, column 2 to line 139, column 61)",
  " (in 'gMAP', line 155, column 6 to column 106)",
  " (in 'gMAP', line 154, column 18 to line 156, column 5)",
  " (in 'gMAP', line 154, column 4 to line 156, column 5)",
  " (in 'gMAP', line 153, column 9 to line 157, column 3)",
  " (in 'gMAP', line 150, column 8 to column 109)",
  " (in 'gMAP', line 149, column 20 to line 151, column 7)",
  " (in 'gMAP', line 149, column 6 to line 151, column 7)",
  " (in 'gMAP', line 148, column 11 to line 152, column 5)",
  " (in 'gMAP', line 146, column 8 to column 73)",
  " (in 'gMAP', line 145, column 20 to line 147, column 7)",
  " (in 'gMAP', line 145, column 6 to line 147, column 7)",
  " (in 'gMAP', line 142, column 26 to line 148, column 5)",
  " (in 'gMAP', line 142, column 4 to line 152, column 5)",
  " (in 'gMAP', line 141, column 10 to line 153, column 3)",
  " (in 'gMAP', line 141, column 2 to line 157, column 3)",
  " (in 'gMAP', line 197, column 19 to column 91)",
  " (in 'gMAP', line 197, column 2 to column 91)",
  " (in 'gMAP', line 198, column 19 to column 91)",
  " (in 'gMAP', line 198, column 2 to column 91)",
  " (in 'gMAP', line 199, column 16 to column 55)",
  " (in 'gMAP', line 199, column 2 to column 55)",
  " (in 'gMAP', line 200, column 16 to column 56)",
  " (in 'gMAP', line 200, column 2 to column 56)",
  " (in 'gMAP', line 201, column 16 to column 56)",
  " (in 'gMAP', line 201, column 2 to column 56)",
  " (in 'gMAP', line 166, column 21 to column 137)",
  " (in 'gMAP', line 166, column 4 to column 137)",
  " (in 'gMAP', line 167, column 21 to column 153)",
  " (in 'gMAP', line 167, column 4 to column 153)",
  " (in 'gMAP', line 164, column 9 to line 168, column 3)",
  " (in 'gMAP', line 162, column 21 to column 60)",
  " (in 'gMAP', line 162, column 4 to column 60)",
  " (in 'gMAP', line 163, column 21 to column 60)",
  " (in 'gMAP', line 163, column 4 to column 60)",
  " (in 'gMAP', line 160, column 11 to line 164, column 3)",
  " (in 'gMAP', line 160, column 2 to line 168, column 3)",
  " (in 'gMAP', line 170, column 2 to column 56)",
  " (in 'gMAP', line 172, column 27 to column 67)",
  " (in 'gMAP', line 172, column 2 to column 67)",
  " (in 'gMAP', line 174, column 27 to column 83)",
  " (in 'gMAP', line 174, column 2 to column 83)",
  " (in 'gMAP', line 176, column 27 to column 83)",
  " (in 'gMAP', line 176, column 2 to column 83)",
  " (in 'gMAP', line 177, column 27 to column 83)",
  " (in 'gMAP', line 177, column 2 to column 83)",
  " (in 'gMAP', line 178, column 27 to column 83)",
  " (in 'gMAP', line 178, column 2 to column 83)",
  " (in 'gMAP', line 179, column 27 to column 83)",
  " (in 'gMAP', line 179, column 2 to column 83)",
  " (in 'gMAP', line 180, column 27 to column 83)",
  " (in 'gMAP', line 180, column 2 to column 83)",
  " (in 'gMAP', line 181, column 27 to column 83)",
  " (in 'gMAP', line 181, column 2 to column 83)",
  " (in 'gMAP', line 182, column 27 to column 64)",
  " (in 'gMAP', line 182, column 2 to column 64)",
  " (in 'gMAP', line 184, column 27 to column 64)",
  " (in 'gMAP', line 184, column 2 to column 64)",
  " (in 'gMAP', line 188, column 18 to column 60)",
  " (in 'gMAP', line 188, column 4 to column 60)",
  " (in 'gMAP', line 189, column 18 to column 54)",
  " (in 'gMAP', line 189, column 4 to column 54)",
  " (in 'gMAP', line 190, column 18 to column 58)",
  " (in 'gMAP', line 190, column 4 to column 58)",
  " (in 'gMAP', line 187, column 16 to line 191, column 3)",
  " (in 'gMAP', line 187, column 2 to line 191, column 3)",
  " (in 'gMAP', line 17, column 2 to column 17)",
  " (in 'gMAP', line 19, column 2 to column 28)",
  " (in 'gMAP', line 21, column 9 to column 10)",
  " (in 'gMAP', line 21, column 2 to column 14)",
  " (in 'gMAP', line 22, column 9 to column 10)",
  " (in 'gMAP', line 22, column 2 to column 17)",
  " (in 'gMAP', line 25, column 8 to column 9)",
  " (in 'gMAP', line 25, column 2 to column 29)",
  " (in 'gMAP', line 26, column 8 to column 9)",
  " (in 'gMAP', line 26, column 2 to column 29)",
  " (in 'gMAP', line 28, column 8 to column 9)",
  " (in 'gMAP', line 28, column 2 to column 30)",
  " (in 'gMAP', line 29, column 9 to column 10)",
  " (in 'gMAP', line 29, column 2 to column 26)",
  " (in 'gMAP', line 31, column 2 to column 24)",
  " (in 'gMAP', line 32, column 8 to column 9)",
  " (in 'gMAP', line 32, column 2 to column 51)",
  " (in 'gMAP', line 34, column 2 to column 43)",
  " (in 'gMAP', line 35, column 2 to column 50)",
  " (in 'gMAP', line 37, column 8 to column 9)",
  " (in 'gMAP', line 37, column 2 to column 60)",
  " (in 'gMAP', line 39, column 2 to column 18)",
  " (in 'gMAP', line 41, column 9 to column 10)",
  " (in 'gMAP', line 41, column 11 to column 13)",
  " (in 'gMAP', line 41, column 2 to column 17)",
  " (in 'gMAP', line 46, column 9 to column 11)",
  " (in 'gMAP', line 46, column 2 to column 26)",
  " (in 'gMAP', line 47, column 9 to column 21)",
  " (in 'gMAP', line 47, column 2 to column 35)",
  " (in 'gMAP', line 49, column 2 to column 39)",
  " (in 'gMAP', line 50, column 2 to column 32)",
  " (in 'gMAP', line 51, column 2 to column 29)",
  " (in 'gMAP', line 53, column 2 to column 27)",
  " (in 'gMAP', line 55, column 18 to column 20)",
  " (in 'gMAP', line 55, column 2 to column 37)",
  " (in 'gMAP', line 56, column 2 to column 36)",
  " (in 'gMAP', line 58, column 2 to column 32)",
  " (in 'gMAP', line 61, column 18 to column 20)",
  " (in 'gMAP', line 61, column 2 to column 38)",
  " (in 'gMAP', line 62, column 18 to column 30)",
  " (in 'gMAP', line 62, column 2 to column 47)",
  " (in 'gMAP', line 65, column 9 to column 10)",
  " (in 'gMAP', line 65, column 12 to column 14)",
  " (in 'gMAP', line 65, column 2 to column 24)",
  " (in 'gMAP', line 67, column 8 to column 16)",
  " (in 'gMAP', line 67, column 2 to column 107)",
  " (in 'gMAP', line 69, column 4 to column 43)",
  " (in 'gMAP', line 70, column 4 to column 43)",
  " (in 'gMAP', line 68, column 18 to line 71, column 3)",
  " (in 'gMAP', line 68, column 2 to line 71, column 3)",
  " (in 'gMAP', line 74, column 4 to column 41)",
  " (in 'gMAP', line 75, column 4 to column 41)",
  " (in 'gMAP', line 73, column 28 to line 76, column 3)",
  " (in 'gMAP', line 73, column 2 to line 76, column 3)",
  " (in 'gMAP', line 79, column 4 to column 60)",
  " (in 'gMAP', line 78, column 17 to line 80, column 3)",
  " (in 'gMAP', line 78, column 2 to line 80, column 3)",
  " (in 'gMAP', line 94, column 2 to column 30)",
  " (in 'gMAP', line 95, column 27 to column 76)",
  " (in 'gMAP', line 95, column 2 to column 76)",
  " (in 'gMAP', line 96, column 27 to column 75)",
  " (in 'gMAP', line 96, column 2 to column 75)",
  " (in 'gMAP', line 97, column 27 to column 72)",
  " (in 'gMAP', line 97, column 2 to column 72)",
  " (in 'gMAP', line 99, column 27 to column 59)",
  " (in 'gMAP', line 99, column 2 to column 59)",
  " (in 'gMAP', line 100, column 27 to column 64)",
  " (in 'gMAP', line 100, column 2 to column 64)",
  " (in 'gMAP', line 101, column 27 to column 65)",
  " (in 'gMAP', line 101, column 2 to column 65)",
  " (in 'gMAP', line 102, column 27 to column 61)",
  " (in 'gMAP', line 102, column 2 to column 61)",
  " (in 'gMAP', line 103, column 27 to column 59)",
  " (in 'gMAP', line 103, column 2 to column 59)",
  " (in 'gMAP', line 104, column 27 to column 62)",
  " (in 'gMAP', line 104, column 2 to column 62)",
  " (in 'gMAP', line 105, column 27 to column 63)",
  " (in 'gMAP', line 105, column 2 to column 63)",
  " (in 'gMAP', line 106, column 27 to column 65)",
  " (in 'gMAP', line 106, column 2 to column 65)",
  " (in 'gMAP', line 107, column 27 to column 65)",
  " (in 'gMAP', line 107, column 2 to column 65)",
  " (in 'gMAP', line 108, column 27 to column 60)",
  " (in 'gMAP', line 108, column 2 to column 60)",
  " (in 'gMAP', line 109, column 27 to column 84)",
  " (in 'gMAP', line 109, column 2 to column 84)",
  " (in 'gMAP', line 114, column 4 to column 39)",
  " (in 'gMAP', line 115, column 4 to column 16)",
  " (in 'gMAP', line 118, column 8 to column 88)",
  " (in 'gMAP', line 117, column 6 to line 118, column 88)",
  " (in 'gMAP', line 119, column 6 to column 23)",
  " (in 'gMAP', line 116, column 19 to line 120, column 5)",
  " (in 'gMAP', line 116, column 4 to line 120, column 5)",
  " (in 'gMAP', line 113, column 9 to line 121, column 3)",
  " (in 'gMAP', line 111, column 4 to column 16)",
  " (in 'gMAP', line 112, column 4 to column 43)",
  " (in 'gMAP', line 110, column 10 to line 113, column 3)",
  " (in 'gMAP', line 110, column 2 to line 121, column 3)",
  " (in 'gMAP', line 123, column 4 to column 64)",
  " (in 'gMAP', line 122, column 2 to line 123, column 64)",
  " (in 'gMAP', line 126, column 9 to column 11)",
  " (in 'gMAP', line 127, column 9 to column 21)",
  " (in 'gMAP', line 128, column 9 to column 17)",
  " (in 'gMAP', line 131, column 9 to column 10)",
  " (in 'gMAP', line 132, column 9 to column 11)",
  " (in 'gMAP', line 133, column 9 to column 21)"};
#include <stan_meta_header.hpp>
class model_gMAP final : public model_base_crtp<model_gMAP> {
private:
  int H;
  int link;
  Eigen::Matrix<double,-1,1> y_data__;
  Eigen::Matrix<double,-1,1> y_se_data__;
  std::vector<int> r;
  std::vector<int> r_n;
  std::vector<int> count;
  Eigen::Matrix<double,-1,1> log_offset_data__;
  int n_groups;
  std::vector<int> group_index;
  int n_tau_strata;
  int tau_strata_pred;
  std::vector<int> tau_strata_index;
  int mX;
  Eigen::Matrix<double,-1,-1> X_data__;
  Eigen::Matrix<double,-1,-1> beta_prior_data__;
  Eigen::Matrix<double,-1,-1> tau_prior_data__;
  int tau_prior_dist;
  int re_dist;
  double re_dist_t_df;
  int ncp;
  std::vector<Eigen::Matrix<double,-1,1>> beta_raw_guess;
  std::vector<double> tau_raw_guess;
  int prior_PD;
  std::vector<Eigen::Matrix<double,-1,1>> beta_prior_stan;
  std::vector<Eigen::Matrix<double,-1,1>> tau_prior_stan;
  Eigen::Matrix<double,-1,-1> X_param_data__;
  std::vector<int> tau_strata_gindex;
  Eigen::Map<Eigen::Matrix<double,-1,1>> y{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> y_se{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> log_offset{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> beta_prior{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> tau_prior{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_param{nullptr, 0, 0};
public:
  ~model_gMAP() {}
  model_gMAP(stan::io::var_context& context__, unsigned int
             random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "model_gMAP_namespace::model_gMAP";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 78;
      context__.validate_dims("data initialization", "H", "int",
        std::vector<size_t>{});
      H = std::numeric_limits<int>::min();
      current_statement__ = 78;
      H = context__.vals_i("H")[(1 - 1)];
      current_statement__ = 78;
      stan::math::check_greater_or_equal(function__, "H", H, 1);
      current_statement__ = 79;
      context__.validate_dims("data initialization", "link", "int",
        std::vector<size_t>{});
      link = std::numeric_limits<int>::min();
      current_statement__ = 79;
      link = context__.vals_i("link")[(1 - 1)];
      current_statement__ = 79;
      stan::math::check_greater_or_equal(function__, "link", link, 1);
      current_statement__ = 79;
      stan::math::check_less_or_equal(function__, "link", link, 3);
      current_statement__ = 80;
      stan::math::validate_non_negative_index("y", "H", H);
      current_statement__ = 81;
      context__.validate_dims("data initialization", "y", "double",
        std::vector<size_t>{static_cast<size_t>(H)});
      y_data__ = Eigen::Matrix<double,-1,1>::Constant(H,
                   std::numeric_limits<double>::quiet_NaN());
      new (&y) Eigen::Map<Eigen::Matrix<double,-1,1>>(y_data__.data(), H);
      {
        std::vector<local_scalar_t__> y_flat__;
        current_statement__ = 81;
        y_flat__ = context__.vals_r("y");
        current_statement__ = 81;
        pos__ = 1;
        current_statement__ = 81;
        for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
          current_statement__ = 81;
          stan::model::assign(y, y_flat__[(pos__ - 1)],
            "assigning variable y", stan::model::index_uni(sym1__));
          current_statement__ = 81;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 82;
      stan::math::validate_non_negative_index("y_se", "H", H);
      current_statement__ = 83;
      context__.validate_dims("data initialization", "y_se", "double",
        std::vector<size_t>{static_cast<size_t>(H)});
      y_se_data__ = Eigen::Matrix<double,-1,1>::Constant(H,
                      std::numeric_limits<double>::quiet_NaN());
      new (&y_se) Eigen::Map<Eigen::Matrix<double,-1,1>>(y_se_data__.data(),
        H);
      {
        std::vector<local_scalar_t__> y_se_flat__;
        current_statement__ = 83;
        y_se_flat__ = context__.vals_r("y_se");
        current_statement__ = 83;
        pos__ = 1;
        current_statement__ = 83;
        for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
          current_statement__ = 83;
          stan::model::assign(y_se, y_se_flat__[(pos__ - 1)],
            "assigning variable y_se", stan::model::index_uni(sym1__));
          current_statement__ = 83;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 84;
      stan::math::validate_non_negative_index("r", "H", H);
      current_statement__ = 85;
      context__.validate_dims("data initialization", "r", "int",
        std::vector<size_t>{static_cast<size_t>(H)});
      r = std::vector<int>(H, std::numeric_limits<int>::min());
      current_statement__ = 85;
      r = context__.vals_i("r");
      current_statement__ = 85;
      stan::math::check_greater_or_equal(function__, "r", r, 0);
      current_statement__ = 86;
      stan::math::validate_non_negative_index("r_n", "H", H);
      current_statement__ = 87;
      context__.validate_dims("data initialization", "r_n", "int",
        std::vector<size_t>{static_cast<size_t>(H)});
      r_n = std::vector<int>(H, std::numeric_limits<int>::min());
      current_statement__ = 87;
      r_n = context__.vals_i("r_n");
      current_statement__ = 87;
      stan::math::check_greater_or_equal(function__, "r_n", r_n, 1);
      current_statement__ = 88;
      stan::math::validate_non_negative_index("count", "H", H);
      current_statement__ = 89;
      context__.validate_dims("data initialization", "count", "int",
        std::vector<size_t>{static_cast<size_t>(H)});
      count = std::vector<int>(H, std::numeric_limits<int>::min());
      current_statement__ = 89;
      count = context__.vals_i("count");
      current_statement__ = 89;
      stan::math::check_greater_or_equal(function__, "count", count, 0);
      current_statement__ = 90;
      stan::math::validate_non_negative_index("log_offset", "H", H);
      current_statement__ = 91;
      context__.validate_dims("data initialization", "log_offset", "double",
        std::vector<size_t>{static_cast<size_t>(H)});
      log_offset_data__ = Eigen::Matrix<double,-1,1>::Constant(H,
                            std::numeric_limits<double>::quiet_NaN());
      new (&log_offset)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(log_offset_data__.data(), H);
      {
        std::vector<local_scalar_t__> log_offset_flat__;
        current_statement__ = 91;
        log_offset_flat__ = context__.vals_r("log_offset");
        current_statement__ = 91;
        pos__ = 1;
        current_statement__ = 91;
        for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
          current_statement__ = 91;
          stan::model::assign(log_offset, log_offset_flat__[(pos__ - 1)],
            "assigning variable log_offset", stan::model::index_uni(sym1__));
          current_statement__ = 91;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 92;
      context__.validate_dims("data initialization", "n_groups", "int",
        std::vector<size_t>{});
      n_groups = std::numeric_limits<int>::min();
      current_statement__ = 92;
      n_groups = context__.vals_i("n_groups")[(1 - 1)];
      current_statement__ = 92;
      stan::math::check_greater_or_equal(function__, "n_groups", n_groups, 1);
      current_statement__ = 93;
      stan::math::validate_non_negative_index("group_index", "H", H);
      current_statement__ = 94;
      context__.validate_dims("data initialization", "group_index", "int",
        std::vector<size_t>{static_cast<size_t>(H)});
      group_index = std::vector<int>(H, std::numeric_limits<int>::min());
      current_statement__ = 94;
      group_index = context__.vals_i("group_index");
      current_statement__ = 94;
      stan::math::check_greater_or_equal(function__, "group_index",
        group_index, 1);
      current_statement__ = 94;
      stan::math::check_less_or_equal(function__, "group_index", group_index,
        n_groups);
      current_statement__ = 95;
      context__.validate_dims("data initialization", "n_tau_strata", "int",
        std::vector<size_t>{});
      n_tau_strata = std::numeric_limits<int>::min();
      current_statement__ = 95;
      n_tau_strata = context__.vals_i("n_tau_strata")[(1 - 1)];
      current_statement__ = 95;
      stan::math::check_greater_or_equal(function__, "n_tau_strata",
        n_tau_strata, 1);
      current_statement__ = 95;
      stan::math::check_less_or_equal(function__, "n_tau_strata",
        n_tau_strata, n_groups);
      current_statement__ = 96;
      context__.validate_dims("data initialization", "tau_strata_pred",
        "int", std::vector<size_t>{});
      tau_strata_pred = std::numeric_limits<int>::min();
      current_statement__ = 96;
      tau_strata_pred = context__.vals_i("tau_strata_pred")[(1 - 1)];
      current_statement__ = 96;
      stan::math::check_greater_or_equal(function__, "tau_strata_pred",
        tau_strata_pred, 1);
      current_statement__ = 96;
      stan::math::check_less_or_equal(function__, "tau_strata_pred",
        tau_strata_pred, n_tau_strata);
      current_statement__ = 97;
      stan::math::validate_non_negative_index("tau_strata_index", "H", H);
      current_statement__ = 98;
      context__.validate_dims("data initialization", "tau_strata_index",
        "int", std::vector<size_t>{static_cast<size_t>(H)});
      tau_strata_index = std::vector<int>(H, std::numeric_limits<int>::min());
      current_statement__ = 98;
      tau_strata_index = context__.vals_i("tau_strata_index");
      current_statement__ = 98;
      stan::math::check_greater_or_equal(function__, "tau_strata_index",
        tau_strata_index, 1);
      current_statement__ = 98;
      stan::math::check_less_or_equal(function__, "tau_strata_index",
        tau_strata_index, n_tau_strata);
      current_statement__ = 99;
      context__.validate_dims("data initialization", "mX", "int",
        std::vector<size_t>{});
      mX = std::numeric_limits<int>::min();
      current_statement__ = 99;
      mX = context__.vals_i("mX")[(1 - 1)];
      current_statement__ = 99;
      stan::math::check_greater_or_equal(function__, "mX", mX, 1);
      current_statement__ = 100;
      stan::math::validate_non_negative_index("X", "H", H);
      current_statement__ = 101;
      stan::math::validate_non_negative_index("X", "mX", mX);
      current_statement__ = 102;
      context__.validate_dims("data initialization", "X", "double",
        std::vector<size_t>{static_cast<size_t>(H), static_cast<size_t>(mX)});
      X_data__ = Eigen::Matrix<double,-1,-1>::Constant(H, mX,
                   std::numeric_limits<double>::quiet_NaN());
      new (&X) Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_data__.data(), H,
        mX);
      {
        std::vector<local_scalar_t__> X_flat__;
        current_statement__ = 102;
        X_flat__ = context__.vals_r("X");
        current_statement__ = 102;
        pos__ = 1;
        current_statement__ = 102;
        for (int sym1__ = 1; sym1__ <= mX; ++sym1__) {
          current_statement__ = 102;
          for (int sym2__ = 1; sym2__ <= H; ++sym2__) {
            current_statement__ = 102;
            stan::model::assign(X, X_flat__[(pos__ - 1)],
              "assigning variable X", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 102;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 103;
      stan::math::validate_non_negative_index("beta_prior", "mX", mX);
      current_statement__ = 104;
      context__.validate_dims("data initialization", "beta_prior", "double",
        std::vector<size_t>{static_cast<size_t>(mX), static_cast<size_t>(2)});
      beta_prior_data__ = Eigen::Matrix<double,-1,-1>::Constant(mX, 2,
                            std::numeric_limits<double>::quiet_NaN());
      new (&beta_prior)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(beta_prior_data__.data(), mX,
        2);
      {
        std::vector<local_scalar_t__> beta_prior_flat__;
        current_statement__ = 104;
        beta_prior_flat__ = context__.vals_r("beta_prior");
        current_statement__ = 104;
        pos__ = 1;
        current_statement__ = 104;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 104;
          for (int sym2__ = 1; sym2__ <= mX; ++sym2__) {
            current_statement__ = 104;
            stan::model::assign(beta_prior, beta_prior_flat__[(pos__ - 1)],
              "assigning variable beta_prior",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 104;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 105;
      stan::math::validate_non_negative_index("tau_prior", "n_tau_strata",
        n_tau_strata);
      current_statement__ = 106;
      context__.validate_dims("data initialization", "tau_prior", "double",
        std::vector<size_t>{static_cast<size_t>(n_tau_strata),
          static_cast<size_t>(2)});
      tau_prior_data__ = Eigen::Matrix<double,-1,-1>::Constant(n_tau_strata,
                           2, std::numeric_limits<double>::quiet_NaN());
      new (&tau_prior)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(tau_prior_data__.data(),
        n_tau_strata, 2);
      {
        std::vector<local_scalar_t__> tau_prior_flat__;
        current_statement__ = 106;
        tau_prior_flat__ = context__.vals_r("tau_prior");
        current_statement__ = 106;
        pos__ = 1;
        current_statement__ = 106;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 106;
          for (int sym2__ = 1; sym2__ <= n_tau_strata; ++sym2__) {
            current_statement__ = 106;
            stan::model::assign(tau_prior, tau_prior_flat__[(pos__ - 1)],
              "assigning variable tau_prior", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 106;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 107;
      context__.validate_dims("data initialization", "tau_prior_dist", "int",
        std::vector<size_t>{});
      tau_prior_dist = std::numeric_limits<int>::min();
      current_statement__ = 107;
      tau_prior_dist = context__.vals_i("tau_prior_dist")[(1 - 1)];
      current_statement__ = 107;
      stan::math::check_greater_or_equal(function__, "tau_prior_dist",
        tau_prior_dist, -1);
      current_statement__ = 107;
      stan::math::check_less_or_equal(function__, "tau_prior_dist",
        tau_prior_dist, 7);
      current_statement__ = 108;
      context__.validate_dims("data initialization", "re_dist", "int",
        std::vector<size_t>{});
      re_dist = std::numeric_limits<int>::min();
      current_statement__ = 108;
      re_dist = context__.vals_i("re_dist")[(1 - 1)];
      current_statement__ = 108;
      stan::math::check_greater_or_equal(function__, "re_dist", re_dist, 0);
      current_statement__ = 108;
      stan::math::check_less_or_equal(function__, "re_dist", re_dist, 1);
      current_statement__ = 109;
      context__.validate_dims("data initialization", "re_dist_t_df",
        "double", std::vector<size_t>{});
      re_dist_t_df = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 109;
      re_dist_t_df = context__.vals_r("re_dist_t_df")[(1 - 1)];
      current_statement__ = 109;
      stan::math::check_greater_or_equal(function__, "re_dist_t_df",
        re_dist_t_df, 0);
      current_statement__ = 110;
      context__.validate_dims("data initialization", "ncp", "int",
        std::vector<size_t>{});
      ncp = std::numeric_limits<int>::min();
      current_statement__ = 110;
      ncp = context__.vals_i("ncp")[(1 - 1)];
      current_statement__ = 110;
      stan::math::check_greater_or_equal(function__, "ncp", ncp, 0);
      current_statement__ = 110;
      stan::math::check_less_or_equal(function__, "ncp", ncp, 1);
      current_statement__ = 111;
      stan::math::validate_non_negative_index("beta_raw_guess", "mX", mX);
      current_statement__ = 112;
      context__.validate_dims("data initialization", "beta_raw_guess",
        "double",
        std::vector<size_t>{static_cast<size_t>(2), static_cast<size_t>(mX)});
      beta_raw_guess = std::vector<Eigen::Matrix<double,-1,1>>(2,
                         Eigen::Matrix<double,-1,1>::Constant(mX,
                           std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> beta_raw_guess_flat__;
        current_statement__ = 112;
        beta_raw_guess_flat__ = context__.vals_r("beta_raw_guess");
        current_statement__ = 112;
        pos__ = 1;
        current_statement__ = 112;
        for (int sym1__ = 1; sym1__ <= mX; ++sym1__) {
          current_statement__ = 112;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 112;
            stan::model::assign(beta_raw_guess, beta_raw_guess_flat__[(pos__
              - 1)], "assigning variable beta_raw_guess",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 112;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 113;
      context__.validate_dims("data initialization", "tau_raw_guess",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      tau_raw_guess = std::vector<double>(2,
                        std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 113;
      tau_raw_guess = context__.vals_r("tau_raw_guess");
      current_statement__ = 114;
      context__.validate_dims("data initialization", "prior_PD", "int",
        std::vector<size_t>{});
      prior_PD = std::numeric_limits<int>::min();
      current_statement__ = 114;
      prior_PD = context__.vals_i("prior_PD")[(1 - 1)];
      current_statement__ = 114;
      stan::math::check_greater_or_equal(function__, "prior_PD", prior_PD, 0);
      current_statement__ = 114;
      stan::math::check_less_or_equal(function__, "prior_PD", prior_PD, 1);
      current_statement__ = 115;
      stan::math::validate_non_negative_index("beta_prior_stan", "mX", mX);
      current_statement__ = 116;
      beta_prior_stan = std::vector<Eigen::Matrix<double,-1,1>>(2,
                          Eigen::Matrix<double,-1,1>::Constant(mX,
                            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 117;
      stan::math::validate_non_negative_index("tau_prior_stan",
        "n_tau_strata", n_tau_strata);
      current_statement__ = 118;
      tau_prior_stan = std::vector<Eigen::Matrix<double,-1,1>>(2,
                         Eigen::Matrix<double,-1,1>::Constant(n_tau_strata,
                           std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 119;
      stan::math::validate_non_negative_index("X_param", "H", H);
      current_statement__ = 120;
      stan::math::validate_non_negative_index("X_param", "mX", mX);
      current_statement__ = 121;
      X_param_data__ = Eigen::Matrix<double,-1,-1>::Constant(H, mX,
                         std::numeric_limits<double>::quiet_NaN());
      new (&X_param)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_param_data__.data(), H, mX);
      current_statement__ = 122;
      stan::math::validate_non_negative_index("tau_strata_gindex",
        "n_groups", n_groups);
      current_statement__ = 123;
      tau_strata_gindex = std::vector<int>(n_groups,
                            std::numeric_limits<int>::min());
      current_statement__ = 123;
      stan::model::assign(tau_strata_gindex,
        stan::math::rep_array(tau_strata_pred, n_groups),
        "assigning variable tau_strata_gindex");
      current_statement__ = 127;
      for (int i = 1; i <= mX; ++i) {
        current_statement__ = 124;
        stan::model::assign(beta_prior_stan,
          stan::model::rvalue(beta_prior, "beta_prior",
            stan::model::index_uni(i), stan::model::index_uni(1)),
          "assigning variable beta_prior_stan", stan::model::index_uni(1),
          stan::model::index_uni(i));
        current_statement__ = 125;
        stan::model::assign(beta_prior_stan,
          stan::model::rvalue(beta_prior, "beta_prior",
            stan::model::index_uni(i), stan::model::index_uni(2)),
          "assigning variable beta_prior_stan", stan::model::index_uni(2),
          stan::model::index_uni(i));
      }
      current_statement__ = 131;
      for (int i = 1; i <= n_tau_strata; ++i) {
        current_statement__ = 128;
        stan::model::assign(tau_prior_stan,
          stan::model::rvalue(tau_prior, "tau_prior",
            stan::model::index_uni(i), stan::model::index_uni(1)),
          "assigning variable tau_prior_stan", stan::model::index_uni(1),
          stan::model::index_uni(i));
        current_statement__ = 129;
        stan::model::assign(tau_prior_stan,
          stan::model::rvalue(tau_prior, "tau_prior",
            stan::model::index_uni(i), stan::model::index_uni(2)),
          "assigning variable tau_prior_stan", stan::model::index_uni(2),
          stan::model::index_uni(i));
      }
      current_statement__ = 134;
      for (int i = 1; i <= H; ++i) {
        current_statement__ = 132;
        stan::model::assign(tau_strata_gindex,
          stan::model::rvalue(tau_strata_index, "tau_strata_index",
            stan::model::index_uni(i)),
          "assigning variable tau_strata_gindex",
          stan::model::index_uni(
            stan::model::rvalue(group_index, "group_index",
              stan::model::index_uni(i))));
      }
      current_statement__ = 135;
      if (pstream__) {
        stan::math::stan_print(pstream__, "Stan gMAP analysis");
        *(pstream__) << std::endl;
      }
      current_statement__ = 137;
      if (stan::math::logical_eq(link, 1)) {
        current_statement__ = 136;
        if (pstream__) {
          stan::math::stan_print(pstream__,
            "likelihood:      Normal (identity link)");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 139;
      if (stan::math::logical_eq(link, 2)) {
        current_statement__ = 138;
        if (pstream__) {
          stan::math::stan_print(pstream__,
            "likelihood:      Binomial (logit link)");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 141;
      if (stan::math::logical_eq(link, 3)) {
        current_statement__ = 140;
        if (pstream__) {
          stan::math::stan_print(pstream__,
            "likelihood:      Poisson (log link)");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 143;
      if (stan::math::logical_eq(tau_prior_dist, -1)) {
        current_statement__ = 142;
        if (pstream__) {
          stan::math::stan_print(pstream__, "tau distrib.:    Fixed");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 145;
      if (stan::math::logical_eq(tau_prior_dist, 0)) {
        current_statement__ = 144;
        if (pstream__) {
          stan::math::stan_print(pstream__, "tau distrib.:    HalfNormal");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 147;
      if (stan::math::logical_eq(tau_prior_dist, 1)) {
        current_statement__ = 146;
        if (pstream__) {
          stan::math::stan_print(pstream__, "tau distrib.:    TruncNormal");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 149;
      if (stan::math::logical_eq(tau_prior_dist, 2)) {
        current_statement__ = 148;
        if (pstream__) {
          stan::math::stan_print(pstream__, "tau distrib.:    Uniform");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 151;
      if (stan::math::logical_eq(tau_prior_dist, 3)) {
        current_statement__ = 150;
        if (pstream__) {
          stan::math::stan_print(pstream__, "tau distrib.:    Gamma");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 153;
      if (stan::math::logical_eq(tau_prior_dist, 4)) {
        current_statement__ = 152;
        if (pstream__) {
          stan::math::stan_print(pstream__, "tau distrib.:    InvGamma");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 155;
      if (stan::math::logical_eq(tau_prior_dist, 5)) {
        current_statement__ = 154;
        if (pstream__) {
          stan::math::stan_print(pstream__, "tau distrib.:    LogNormal");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 157;
      if (stan::math::logical_eq(tau_prior_dist, 6)) {
        current_statement__ = 156;
        if (pstream__) {
          stan::math::stan_print(pstream__, "tau distrib.:    TruncCauchy");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 159;
      if (stan::math::logical_eq(tau_prior_dist, 7)) {
        current_statement__ = 158;
        if (pstream__) {
          stan::math::stan_print(pstream__, "tau distrib.:    Exponential");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 161;
      if (stan::math::logical_eq(re_dist, 0)) {
        current_statement__ = 160;
        if (pstream__) {
          stan::math::stan_print(pstream__, "random effects:  Normal");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 163;
      if (stan::math::logical_eq(re_dist, 1)) {
        current_statement__ = 162;
        if (pstream__) {
          stan::math::stan_print(pstream__,
            "random effects:  Student-t, df = ");
          stan::math::stan_print(pstream__, re_dist_t_df);
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 175;
      if (ncp) {
        current_statement__ = 172;
        stan::model::assign(X_param, X, "assigning variable X_param");
        current_statement__ = 173;
        if (pstream__) {
          stan::math::stan_print(pstream__, "parametrization: Non-Centered");
          *(pstream__) << std::endl;
        }
      } else {
        current_statement__ = 164;
        if (pstream__) {
          stan::math::stan_print(pstream__, "parametrization: Centered");
          *(pstream__) << std::endl;
        }
        current_statement__ = 165;
        stan::model::assign(X_param, X, "assigning variable X_param");
        current_statement__ = 170;
        for (int i = 1; i <= H; ++i) {
          current_statement__ = 167;
          if (stan::math::logical_neq(
                stan::model::rvalue(X_param, "X_param",
                  stan::model::index_uni(i), stan::model::index_uni(1)), 1)) {
            current_statement__ = 166;
            std::stringstream errmsg_stream__;
            stan::math::stan_print(&errmsg_stream__,
              "Centered parametrization requires treatment contrast parametrization!");
            throw std::domain_error(errmsg_stream__.str());
          }
          current_statement__ = 168;
          stan::model::assign(X_param, 0, "assigning variable X_param",
            stan::model::index_uni(i), stan::model::index_uni(1));
        }
      }
      current_statement__ = 177;
      if (prior_PD) {
        current_statement__ = 176;
        if (pstream__) {
          stan::math::stan_print(pstream__,
            "Info: Sampling from prior predictive distribution.");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 123;
      stan::math::check_greater_or_equal(function__, "tau_strata_gindex",
        tau_strata_gindex, 1);
      current_statement__ = 123;
      stan::math::check_less_or_equal(function__, "tau_strata_gindex",
        tau_strata_gindex, n_tau_strata);
      current_statement__ = 178;
      stan::math::validate_non_negative_index("beta_raw", "mX", mX);
      current_statement__ = 179;
      stan::math::validate_non_negative_index("tau_raw", "n_tau_strata",
        n_tau_strata);
      current_statement__ = 180;
      stan::math::validate_non_negative_index("xi_eta", "n_groups", n_groups);
      current_statement__ = 181;
      stan::math::validate_non_negative_index("theta", "H", H);
      current_statement__ = 182;
      stan::math::validate_non_negative_index("beta", "mX", mX);
      current_statement__ = 183;
      stan::math::validate_non_negative_index("tau", "n_tau_strata",
        n_tau_strata);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = mX + n_tau_strata + n_groups;
  }
  inline std::string model_name() const final {
    return "model_gMAP";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
             "stancflags = --allow-undefined"};
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "model_gMAP_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> beta_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(mX, DUMMY_VAR__);
      current_statement__ = 1;
      beta_raw = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(mX);
      Eigen::Matrix<local_scalar_t__,-1,1> tau_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_tau_strata,
          DUMMY_VAR__);
      current_statement__ = 2;
      tau_raw = in__.template read<
                  Eigen::Matrix<local_scalar_t__,-1,1>>(n_tau_strata);
      Eigen::Matrix<local_scalar_t__,-1,1> xi_eta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_groups, DUMMY_VAR__);
      current_statement__ = 3;
      xi_eta = in__.template read<
                 Eigen::Matrix<local_scalar_t__,-1,1>>(n_groups);
      Eigen::Matrix<local_scalar_t__,-1,1> theta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(H, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> beta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(mX, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> tau =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_tau_strata,
          DUMMY_VAR__);
      current_statement__ = 9;
      stan::model::assign(beta,
        stan::math::add(
          stan::model::rvalue(beta_raw_guess, "beta_raw_guess",
            stan::model::index_uni(1)),
          stan::math::elt_multiply(
            stan::model::rvalue(beta_raw_guess, "beta_raw_guess",
              stan::model::index_uni(2)), beta_raw)),
        "assigning variable beta");
      current_statement__ = 12;
      if (stan::math::logical_eq(tau_prior_dist, -1)) {
        current_statement__ = 11;
        stan::model::assign(tau,
          stan::model::rvalue(tau_prior_stan, "tau_prior_stan",
            stan::model::index_uni(1)), "assigning variable tau");
      } else {
        current_statement__ = 10;
        stan::model::assign(tau,
          stan::math::exp(
            stan::math::add(
              stan::model::rvalue(tau_raw_guess, "tau_raw_guess",
                stan::model::index_uni(1)),
              stan::math::multiply(
                stan::model::rvalue(tau_raw_guess, "tau_raw_guess",
                  stan::model::index_uni(2)), tau_raw))),
          "assigning variable tau");
      }
      current_statement__ = 27;
      if (ncp) {
        current_statement__ = 25;
        if (stan::math::logical_eq(n_tau_strata, 1)) {
          current_statement__ = 23;
          for (int h = 1; h <= H; ++h) {
            current_statement__ = 21;
            stan::model::assign(theta,
              (stan::math::multiply(
                 stan::model::rvalue(X_param, "X_param",
                   stan::model::index_uni(h)), beta) +
              (stan::model::rvalue(xi_eta, "xi_eta",
                 stan::model::index_uni(
                   stan::model::rvalue(group_index, "group_index",
                     stan::model::index_uni(h)))) *
              stan::model::rvalue(tau, "tau", stan::model::index_uni(1)))),
              "assigning variable theta", stan::model::index_uni(h));
          }
        } else {
          current_statement__ = 19;
          for (int h = 1; h <= H; ++h) {
            current_statement__ = 17;
            stan::model::assign(theta,
              (stan::math::multiply(
                 stan::model::rvalue(X_param, "X_param",
                   stan::model::index_uni(h)), beta) +
              (stan::model::rvalue(xi_eta, "xi_eta",
                 stan::model::index_uni(
                   stan::model::rvalue(group_index, "group_index",
                     stan::model::index_uni(h)))) *
              stan::model::rvalue(tau, "tau",
                stan::model::index_uni(
                  stan::model::rvalue(tau_strata_gindex, "tau_strata_gindex",
                    stan::model::index_uni(
                      stan::model::rvalue(group_index, "group_index",
                        stan::model::index_uni(h)))))))),
              "assigning variable theta", stan::model::index_uni(h));
          }
        }
      } else {
        current_statement__ = 15;
        for (int h = 1; h <= H; ++h) {
          current_statement__ = 13;
          stan::model::assign(theta,
            ((stan::math::multiply(
                stan::model::rvalue(X_param, "X_param",
                  stan::model::index_uni(h)), beta) +
            stan::model::rvalue(beta_raw_guess, "beta_raw_guess",
              stan::model::index_uni(1), stan::model::index_uni(1))) +
            (stan::model::rvalue(beta_raw_guess, "beta_raw_guess",
               stan::model::index_uni(2), stan::model::index_uni(1)) *
            stan::model::rvalue(xi_eta, "xi_eta",
              stan::model::index_uni(
                stan::model::rvalue(group_index, "group_index",
                  stan::model::index_uni(h)))))), "assigning variable theta",
            stan::model::index_uni(h));
        }
      }
      {
        current_statement__ = 48;
        if (ncp) {
          current_statement__ = 44;
          if (stan::math::logical_eq(re_dist, 0)) {
            current_statement__ = 43;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(xi_eta, 0, 1));
          }
          current_statement__ = 46;
          if (stan::math::logical_eq(re_dist, 1)) {
            current_statement__ = 45;
            lp_accum__.add(stan::math::student_t_lpdf<propto__>(xi_eta,
                             re_dist_t_df, 0, 1));
          }
        } else {
          current_statement__ = 39;
          if (stan::math::logical_eq(re_dist, 0)) {
            current_statement__ = 38;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(xi_eta,
                             ((stan::model::rvalue(beta, "beta",
                                 stan::model::index_uni(1)) -
                             stan::model::rvalue(beta_raw_guess,
                               "beta_raw_guess", stan::model::index_uni(1),
                               stan::model::index_uni(1))) /
                             stan::model::rvalue(beta_raw_guess,
                               "beta_raw_guess", stan::model::index_uni(2),
                               stan::model::index_uni(1))),
                             stan::math::divide(
                               stan::model::rvalue(tau, "tau",
                                 stan::model::index_multi(tau_strata_gindex)),
                               stan::model::rvalue(beta_raw_guess,
                                 "beta_raw_guess", stan::model::index_uni(2),
                                 stan::model::index_uni(1)))));
          }
          current_statement__ = 41;
          if (stan::math::logical_eq(re_dist, 1)) {
            current_statement__ = 40;
            lp_accum__.add(stan::math::student_t_lpdf<propto__>(xi_eta,
                             re_dist_t_df,
                             ((stan::model::rvalue(beta, "beta",
                                 stan::model::index_uni(1)) -
                             stan::model::rvalue(beta_raw_guess,
                               "beta_raw_guess", stan::model::index_uni(1),
                               stan::model::index_uni(1))) /
                             stan::model::rvalue(beta_raw_guess,
                               "beta_raw_guess", stan::model::index_uni(2),
                               stan::model::index_uni(1))),
                             stan::math::divide(
                               stan::model::rvalue(tau, "tau",
                                 stan::model::index_multi(tau_strata_gindex)),
                               stan::model::rvalue(beta_raw_guess,
                                 "beta_raw_guess", stan::model::index_uni(2),
                                 stan::model::index_uni(1)))));
          }
        }
        current_statement__ = 49;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(beta,
                         stan::model::rvalue(beta_prior_stan,
                           "beta_prior_stan", stan::model::index_uni(1)),
                         stan::model::rvalue(beta_prior_stan,
                           "beta_prior_stan", stan::model::index_uni(2))));
        current_statement__ = 51;
        if (stan::math::logical_eq(tau_prior_dist, -1)) {
          current_statement__ = 50;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(tau_raw, 0, 1));
        }
        current_statement__ = 53;
        if (stan::math::logical_eq(tau_prior_dist, 0)) {
          current_statement__ = 52;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(tau, 0,
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(2))));
        }
        current_statement__ = 55;
        if (stan::math::logical_eq(tau_prior_dist, 1)) {
          current_statement__ = 54;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(tau,
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(1)),
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(2))));
        }
        current_statement__ = 57;
        if (stan::math::logical_eq(tau_prior_dist, 2)) {
          current_statement__ = 56;
          lp_accum__.add(stan::math::uniform_lpdf<propto__>(tau,
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(1)),
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(2))));
        }
        current_statement__ = 59;
        if (stan::math::logical_eq(tau_prior_dist, 3)) {
          current_statement__ = 58;
          lp_accum__.add(stan::math::gamma_lpdf<propto__>(tau,
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(1)),
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(2))));
        }
        current_statement__ = 61;
        if (stan::math::logical_eq(tau_prior_dist, 4)) {
          current_statement__ = 60;
          lp_accum__.add(stan::math::inv_gamma_lpdf<propto__>(tau,
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(1)),
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(2))));
        }
        current_statement__ = 63;
        if (stan::math::logical_eq(tau_prior_dist, 5)) {
          current_statement__ = 62;
          lp_accum__.add(stan::math::lognormal_lpdf<propto__>(tau,
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(1)),
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(2))));
        }
        current_statement__ = 65;
        if (stan::math::logical_eq(tau_prior_dist, 6)) {
          current_statement__ = 64;
          lp_accum__.add(stan::math::cauchy_lpdf<propto__>(tau,
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(1)),
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(2))));
        }
        current_statement__ = 67;
        if (stan::math::logical_eq(tau_prior_dist, 7)) {
          current_statement__ = 66;
          lp_accum__.add(stan::math::exponential_lpdf<propto__>(tau,
                           stan::model::rvalue(tau_prior_stan,
                             "tau_prior_stan", stan::model::index_uni(1))));
        }
        current_statement__ = 69;
        if (stan::math::logical_neq(tau_prior_dist, -1)) {
          current_statement__ = 68;
          lp_accum__.add(stan::math::multiply(
                           stan::model::rvalue(tau_raw_guess,
                             "tau_raw_guess", stan::model::index_uni(2)),
                           tau_raw));
        }
        current_statement__ = 77;
        if (stan::math::logical_negation(prior_PD)) {
          current_statement__ = 71;
          if (stan::math::logical_eq(link, 1)) {
            current_statement__ = 70;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(y, theta, y_se));
          }
          current_statement__ = 73;
          if (stan::math::logical_eq(link, 2)) {
            current_statement__ = 72;
            lp_accum__.add(stan::math::binomial_logit_lpmf<propto__>(r, r_n,
                             theta));
          }
          current_statement__ = 75;
          if (stan::math::logical_eq(link, 3)) {
            current_statement__ = 74;
            lp_accum__.add(stan::math::poisson_log_lpmf<propto__>(count,
                             stan::math::add(log_offset, theta)));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    static constexpr const char* function__ =
      "model_gMAP_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,1> beta_raw =
        Eigen::Matrix<double,-1,1>::Constant(mX,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      beta_raw = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(mX);
      Eigen::Matrix<double,-1,1> tau_raw =
        Eigen::Matrix<double,-1,1>::Constant(n_tau_strata,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      tau_raw = in__.template read<
                  Eigen::Matrix<local_scalar_t__,-1,1>>(n_tau_strata);
      Eigen::Matrix<double,-1,1> xi_eta =
        Eigen::Matrix<double,-1,1>::Constant(n_groups,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      xi_eta = in__.template read<
                 Eigen::Matrix<local_scalar_t__,-1,1>>(n_groups);
      Eigen::Matrix<double,-1,1> theta =
        Eigen::Matrix<double,-1,1>::Constant(H,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> beta =
        Eigen::Matrix<double,-1,1>::Constant(mX,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> tau =
        Eigen::Matrix<double,-1,1>::Constant(n_tau_strata,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(beta_raw);
      out__.write(tau_raw);
      out__.write(xi_eta);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 9;
      stan::model::assign(beta,
        stan::math::add(
          stan::model::rvalue(beta_raw_guess, "beta_raw_guess",
            stan::model::index_uni(1)),
          stan::math::elt_multiply(
            stan::model::rvalue(beta_raw_guess, "beta_raw_guess",
              stan::model::index_uni(2)), beta_raw)),
        "assigning variable beta");
      current_statement__ = 12;
      if (stan::math::logical_eq(tau_prior_dist, -1)) {
        current_statement__ = 11;
        stan::model::assign(tau,
          stan::model::rvalue(tau_prior_stan, "tau_prior_stan",
            stan::model::index_uni(1)), "assigning variable tau");
      } else {
        current_statement__ = 10;
        stan::model::assign(tau,
          stan::math::exp(
            stan::math::add(
              stan::model::rvalue(tau_raw_guess, "tau_raw_guess",
                stan::model::index_uni(1)),
              stan::math::multiply(
                stan::model::rvalue(tau_raw_guess, "tau_raw_guess",
                  stan::model::index_uni(2)), tau_raw))),
          "assigning variable tau");
      }
      current_statement__ = 27;
      if (ncp) {
        current_statement__ = 25;
        if (stan::math::logical_eq(n_tau_strata, 1)) {
          current_statement__ = 23;
          for (int h = 1; h <= H; ++h) {
            current_statement__ = 21;
            stan::model::assign(theta,
              (stan::math::multiply(
                 stan::model::rvalue(X_param, "X_param",
                   stan::model::index_uni(h)), beta) +
              (stan::model::rvalue(xi_eta, "xi_eta",
                 stan::model::index_uni(
                   stan::model::rvalue(group_index, "group_index",
                     stan::model::index_uni(h)))) *
              stan::model::rvalue(tau, "tau", stan::model::index_uni(1)))),
              "assigning variable theta", stan::model::index_uni(h));
          }
        } else {
          current_statement__ = 19;
          for (int h = 1; h <= H; ++h) {
            current_statement__ = 17;
            stan::model::assign(theta,
              (stan::math::multiply(
                 stan::model::rvalue(X_param, "X_param",
                   stan::model::index_uni(h)), beta) +
              (stan::model::rvalue(xi_eta, "xi_eta",
                 stan::model::index_uni(
                   stan::model::rvalue(group_index, "group_index",
                     stan::model::index_uni(h)))) *
              stan::model::rvalue(tau, "tau",
                stan::model::index_uni(
                  stan::model::rvalue(tau_strata_gindex, "tau_strata_gindex",
                    stan::model::index_uni(
                      stan::model::rvalue(group_index, "group_index",
                        stan::model::index_uni(h)))))))),
              "assigning variable theta", stan::model::index_uni(h));
          }
        }
      } else {
        current_statement__ = 15;
        for (int h = 1; h <= H; ++h) {
          current_statement__ = 13;
          stan::model::assign(theta,
            ((stan::math::multiply(
                stan::model::rvalue(X_param, "X_param",
                  stan::model::index_uni(h)), beta) +
            stan::model::rvalue(beta_raw_guess, "beta_raw_guess",
              stan::model::index_uni(1), stan::model::index_uni(1))) +
            (stan::model::rvalue(beta_raw_guess, "beta_raw_guess",
               stan::model::index_uni(2), stan::model::index_uni(1)) *
            stan::model::rvalue(xi_eta, "xi_eta",
              stan::model::index_uni(
                stan::model::rvalue(group_index, "group_index",
                  stan::model::index_uni(h)))))), "assigning variable theta",
            stan::model::index_uni(h));
        }
      }
      if (emit_transformed_parameters__) {
        out__.write(theta);
        out__.write(beta);
        out__.write(tau);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      double theta_pred = std::numeric_limits<double>::quiet_NaN();
      double theta_resp_pred = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 29;
      if (stan::math::logical_eq(re_dist, 0)) {
        current_statement__ = 28;
        theta_pred = stan::math::normal_rng(
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(1)),
                       stan::model::rvalue(tau, "tau",
                         stan::model::index_uni(tau_strata_pred)), base_rng__);
      }
      current_statement__ = 31;
      if (stan::math::logical_eq(re_dist, 1)) {
        current_statement__ = 30;
        theta_pred = stan::math::student_t_rng(re_dist_t_df,
                       stan::model::rvalue(beta, "beta",
                         stan::model::index_uni(1)),
                       stan::model::rvalue(tau, "tau",
                         stan::model::index_uni(tau_strata_pred)), base_rng__);
      }
      current_statement__ = 33;
      if (stan::math::logical_eq(link, 1)) {
        current_statement__ = 32;
        theta_resp_pred = theta_pred;
      }
      current_statement__ = 35;
      if (stan::math::logical_eq(link, 2)) {
        current_statement__ = 34;
        theta_resp_pred = stan::math::inv_logit(theta_pred);
      }
      current_statement__ = 37;
      if (stan::math::logical_eq(link, 3)) {
        current_statement__ = 36;
        theta_resp_pred = stan::math::exp(theta_pred);
      }
      out__.write(theta_pred);
      out__.write(theta_resp_pred);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> beta_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(mX, DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(beta_raw,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(mX),
        "assigning variable beta_raw");
      out__.write(beta_raw);
      Eigen::Matrix<local_scalar_t__,-1,1> tau_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_tau_strata,
          DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(tau_raw,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_tau_strata),
        "assigning variable tau_raw");
      out__.write(tau_raw);
      Eigen::Matrix<local_scalar_t__,-1,1> xi_eta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_groups, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(xi_eta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(n_groups),
        "assigning variable xi_eta");
      out__.write(xi_eta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "beta_raw",
        "double", std::vector<size_t>{static_cast<size_t>(mX)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "tau_raw",
        "double", std::vector<size_t>{static_cast<size_t>(n_tau_strata)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "xi_eta", "double",
        std::vector<size_t>{static_cast<size_t>(n_groups)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> beta_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(mX, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> beta_raw_flat__;
        current_statement__ = 1;
        beta_raw_flat__ = context__.vals_r("beta_raw");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= mX; ++sym1__) {
          current_statement__ = 1;
          stan::model::assign(beta_raw, beta_raw_flat__[(pos__ - 1)],
            "assigning variable beta_raw", stan::model::index_uni(sym1__));
          current_statement__ = 1;
          pos__ = (pos__ + 1);
        }
      }
      out__.write(beta_raw);
      Eigen::Matrix<local_scalar_t__,-1,1> tau_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_tau_strata,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> tau_raw_flat__;
        current_statement__ = 2;
        tau_raw_flat__ = context__.vals_r("tau_raw");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= n_tau_strata; ++sym1__) {
          current_statement__ = 2;
          stan::model::assign(tau_raw, tau_raw_flat__[(pos__ - 1)],
            "assigning variable tau_raw", stan::model::index_uni(sym1__));
          current_statement__ = 2;
          pos__ = (pos__ + 1);
        }
      }
      out__.write(tau_raw);
      Eigen::Matrix<local_scalar_t__,-1,1> xi_eta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n_groups, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> xi_eta_flat__;
        current_statement__ = 3;
        xi_eta_flat__ = context__.vals_r("xi_eta");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= n_groups; ++sym1__) {
          current_statement__ = 3;
          stan::model::assign(xi_eta, xi_eta_flat__[(pos__ - 1)],
            "assigning variable xi_eta", stan::model::index_uni(sym1__));
          current_statement__ = 3;
          pos__ = (pos__ + 1);
        }
      }
      out__.write(xi_eta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"beta_raw", "tau_raw", "xi_eta"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"theta", "beta", "tau"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string> temp{"theta_pred", "theta_resp_pred"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    mX)},
                std::vector<size_t>{static_cast<size_t>(n_tau_strata)},
                std::vector<size_t>{static_cast<size_t>(n_groups)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(H)},
             std::vector<size_t>{static_cast<size_t>(mX)},
             std::vector<size_t>{static_cast<size_t>(n_tau_strata)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{}, std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= mX; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta_raw" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= n_tau_strata; ++sym1__) {
      param_names__.emplace_back(std::string() + "tau_raw" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= n_groups; ++sym1__) {
      param_names__.emplace_back(std::string() + "xi_eta" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= mX; ++sym1__) {
        param_names__.emplace_back(std::string() + "beta" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= n_tau_strata; ++sym1__) {
        param_names__.emplace_back(std::string() + "tau" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "theta_pred");
      param_names__.emplace_back(std::string() + "theta_resp_pred");
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= mX; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta_raw" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= n_tau_strata; ++sym1__) {
      param_names__.emplace_back(std::string() + "tau_raw" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= n_groups; ++sym1__) {
      param_names__.emplace_back(std::string() + "xi_eta" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= H; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= mX; ++sym1__) {
        param_names__.emplace_back(std::string() + "beta" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= n_tau_strata; ++sym1__) {
        param_names__.emplace_back(std::string() + "tau" + '.' +
          std::to_string(sym1__));
      }
    }
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "theta_pred");
      param_names__.emplace_back(std::string() + "theta_resp_pred");
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"beta_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(mX) + "},\"block\":\"parameters\"},{\"name\":\"tau_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_tau_strata) + "},\"block\":\"parameters\"},{\"name\":\"xi_eta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_groups) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(H) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(mX) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_tau_strata) + "},\"block\":\"transformed_parameters\"},{\"name\":\"theta_pred\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta_resp_pred\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"beta_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(mX) + "},\"block\":\"parameters\"},{\"name\":\"tau_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_tau_strata) + "},\"block\":\"parameters\"},{\"name\":\"xi_eta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_groups) + "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(H) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(mX) + "},\"block\":\"transformed_parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_tau_strata) + "},\"block\":\"transformed_parameters\"},{\"name\":\"theta_pred\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta_resp_pred\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((mX + n_tau_strata) + n_groups);
    const size_t num_transformed = emit_transformed_parameters * (((H + mX) +
      n_tau_strata));
    const size_t num_gen_quantities = emit_generated_quantities * ((1 + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((mX + n_tau_strata) + n_groups);
    const size_t num_transformed = emit_transformed_parameters * (((H + mX) +
      n_tau_strata));
    const size_t num_gen_quantities = emit_generated_quantities * ((1 + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = model_gMAP_namespace::model_gMAP;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_gMAP_namespace::profiles__;
}
#endif
#endif
